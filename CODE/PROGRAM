import math, random

# 1
def factorial(n):
    return 1 if n == 0 else n * factorial(n - 1)

print(factorial(5))

# 2
def is_palindrome(n):
    return str(n) == str(n)[::-1]

print(is_palindrome(121)) 

# 3
def mean_of_digits(n):
    digits = list(map(int, str(n)))
    return sum(digits) / len(digits)

print(mean_of_digits(246))

# 4
def digital_root(n):
    while n > 9:
        n = sum(map(int, str(n)))
    return n

# helper for divisors

def proper_divisors(n):
    return [i for i in range(1, n) if n % i == 0]

print(digital_root(987))

# 5

def is_abundant(n):
    return sum(proper_divisors(n)) > n

print(is_abundant(12)) 

# 6

def is_deficient(n):
    return sum(proper_divisors(n)) < n

print(is_deficient(8))

# 7

def is_harshad(n):
    return n % sum(map(int, str(n))) == 0

print(is_harshad(18))  

# 8

def is_automorphic(n):
    return str(n*n).endswith(str(n))

print(is_automorphic(25))

# 9

def is_pronic(n):
    k = int(math.sqrt(n))
    return k*(k+1) == n

print(is_pronic(12)) 

# 10

def prime_factors(n):
    factors = []
    d = 2
    while d * d <= n:
        while n % d == 0:
            factors.append(d)
            n //= d
        d += 1
    if n > 1:
        factors.append(n)
    return factors

print(prime_factors(84)) 

# 11

def count_distinct_prime_factors(n):
    return len(set(prime_factors(n)))

print(count_distinct_prime_factors(84)) 

# 12

def is_prime_power(n):
    for p in range(2, int(math.sqrt(n)) + 1):
        k = 2
        while p**k <= n:
            if p**k == n:
                return True
            k += 1
    return False

print(is_prime_power(27)) 

# 13

def is_mersenne_prime(p):
    m = 2**p - 1
    return 
# Primality Test Helper

def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

print(is_mersenne_prime(3)) 

# 14

def twin_primes(limit):
    primes = [i for i in range(2, limit+1) if is_prime(i)]
    return [(p, p+2) for p in primes if p+2 in primes]

print(twin_primes(20))   

# 15

def count_divisors(n):
    count = 0
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            count += 2 if i != n//i else 1
    return count

print(count_divisors(36)) 

# 16

def aliquot_sum(n):
    return sum(proper_divisors(n))

print(aliquot_sum(12)) 

# 17

def are_amicable(a, b):
    return aliquot_sum(a) == b and aliquot_sum(b) == a

print(are_amicable(220,284))

# 18

def multiplicative_persistence(n):
    steps = 0
    while n > 9:
        product = 1
        for d in str(n):
            product *= int(d)
        n = product
        steps += 1
    return steps

print(multiplicative_persistence(39))

# 19

def is_highly_composite(n):
    d_n = count_divisors(n)
    return all(count_divisors(i) < d_n for i in range(1, n))

print(is_highly_composite(12))

# 20

def mod_exp(base, exponent, modulus):
    result = 1
    base = base % modulus
    while exponent > 0:
        if exponent % 2 == 1:
            result = (result * base) % modulus
        base = (base * base) % modulus
        exponent //= 2
    return result

print(mod_exp(2,10,1000))   

# 21

def egcd(a, b):
    if b == 0:
        return a, 1, 0
    g, x1, y1 = egcd(b, a % b)
    return g, y1, x1 - (a // b) * y1

def mod_inverse(a, m):
    g, x, _ = egcd(a, m)
    if g != 1:
        return None
    return x % m

print(mod_inverse(3,11)) 

# 22

def crt(remainders, moduli):
    total_mod = math.prod(moduli)
    x = 0
    for r, m in zip(remainders, moduli):
        M = total_mod // m
        inv = mod_inverse(M, m)
        x += r * M * inv
    return x % total_mod

print(crt([2,3],[3,5])) 

# 23

def is_quadratic_residue(a, p):
    return mod_exp(a, (p-1)//2, p) == 1

print(is_quadratic_residue(4,7)) 

# 24

def order_mod(a, n):
    for k in range(1, n):
        if mod_exp(a, k, n) == 1:
            return k
    return None

print(order_mod(2,7))  

# 25

def is_fibonacci_prime(n):
    # check fibonacci
    if not (int(math.sqrt(5*n*n + 4))*2 == 5*n*n + 4 or int(math.sqrt(5*n*n - 4))*2 == 5*n*n - 4):
        return False
    return is_prime(n)

print(is_fibonacci_prime(13)) 

# 26

def lucas_sequence(n):
    seq = [2, 1]
    for i in range(2, n):
        seq.append(seq[-1] + seq[-2])
    return seq[:n]

print(lucas_sequence(10))  

# 27

def is_perfect_power(n):
    for a in range(2, int(math.sqrt(n)) + 1):
        b = 2
        while a**b <= n:
            if a**b == n:
                return True
            b += 1
    return False

print(is_perfect_power(16)) 

# 28

def collatz_length(n):
    steps = 0
    while n != 1:
        n = n//2 if n % 2 == 0 else 3*n + 1
        steps += 1
    return steps

print(collatz_length(6))

# 29

def polygonal_number(s, n):
    return ((s - 2) * n * (n - 1)) // 2 + n

print(polygonal_number(5,4))

# 30

def is_carmichael(n):
    if is_prime(n):
        return False
    for a in range(2, n):
        if math.gcd(a, n) == 1 and mod_exp(a, n-1, n) != 1:
            return False
    return True

print(is_carmichael(561)) 

# 31 â€” Miller-Rabin

def is_prime_miller_rabin(n, k=5):
    if n < 2:
        return False
    s, d = 0, n - 1
    while d % 2 == 0:
        d //= 2
        s += 1
    for _ in range(k):
        a = random.randint(2, n - 2)
        x = mod_exp(a, d, n)
        if x == 1 or x == n - 1:
            continue
        for __ in range(s - 1):
            x = mod_exp(x, 2, n)
            if x == n - 1:
                break
        else:
            return False
    return True

print(is_prime_miller_rabin(97, 5))

# 32 Pollard-Rho

def pollard_rho(n):
    if n % 2 == 0:
        return 2
    x = random.randint(2, n - 1)
    y = x
    c = random.randint(1, n - 1)
    d = 1
    while d == 1:
        x = (x*x + c) % n
        y = (y*y + c) % n
        y = (y*y + c) % n
        d = math.gcd(abs(x - y), n)
    if d == n:
        return None
    return d

print(pollard_rho(91))  

# 33 Zeta Approx

def zeta_approx(s, terms):
    return sum(1/(n**s) for n in range(1, terms + 1))

print(zeta_approx(2,1000))   

# 34 Partition Function

def partition_function(n):
    p = [0] * (n + 1)
    p[0] = 1
    for i in range(1, n + 1):
        for j in range(i, n + 1):
            p[j] += p[j - i]
    return p[n]

print(partition_function(5))
